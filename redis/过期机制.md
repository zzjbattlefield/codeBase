<font size="4">

# Redis数据库过期策略

## 设置过期方法
```go
EXPIRE key seconds　　//将key的生存时间设置为ttl秒
PEXPIRE key milliseconds　　//将key的生成时间设置为ttl毫秒
EXPIREAT key timestamp　　//将key的过期时间设置为timestamp所代表的的秒数的时间戳
PEXPIREAT key milliseconds-timestamp　　//将key的过期时间设置为timestamp所代表的的毫秒数的时间戳
```

## 三种过期策略
- 定时删除
    - 为key创建一个定时器,到时间后对key进行删除
    - 优点:内存尽快释放
    - 缺点:过期key过多删除占用cpu资源 为每一个key创建定时器性能影响严重
- 惰性删除
    - 含义:key过期时不会删除,每次获取到key的时候判断是否过期
    - 优点:删除操作只发生在从数据库取出key的时候发生，而且只删除当前key，所以对CPU时间的占用是比较少的
    - 缺点若大量的key在超出超时时间后，很久一段时间内，都没有被获取过，那么可能发生内存泄露
-定期删除
    - 含义:每隔一段时间执行一次删除(在redis.conf配置文件设置hz，1s刷新的频率)过期key操作
    - 优点:
        - 通过限制删除操作的时长和频率，来减少删除操作对CPU时间的占用--处理"定时删除"的缺点
        - 定期删除过期key--处理"惰性删除"的缺点
    - 缺点:
        - 在内存友好方面，不如"定时删除"
        - 在CPU时间友好方面，不如"惰性删除"
### 总结
定时删除和定期删除为主动删除：Redis会定期主动淘汰一批已过去的key

惰性删除为被动删除：用到的时候才会去检验key是不是已过期，过期就删除

惰性删除为redis服务器内置策略

定期删除可以通过：
- 配置redis.conf 的hz选项，默认为10 （即1秒执行10次，100ms一次，值越大说明刷新频率越快，最Redis性能损耗也越大） 
- 配置redis.conf的maxmemory最大值，当已用内存超过maxmemory限定时，就会触发主动清理策略

## redis过期策略
- 惰性删除流程
    - 在进行get或setnx等操作时，先检查key是否过期，
    - 若过期，删除key，然后执行相应操作；
    - 若没过期，直接执行相应操作
- 定时删除流程
    - 遍历每个数据库（就是redis.conf中配置的"database"数量，默认为16）
    - 检查当前库中的指定个数个key（默认是每个库检查20个key，注意相当于该循环执行20次，循环体时下边的描述）
        - 如果当前库中没有一个key设置了过期时间，直接执行下一个库的遍历
        - 随机获取一个设置了过期时间的key，检查该key是否过期，如果过期，删除key
        - 判断定期删除操作是否已经达到指定时长，若已经达到，直接退出定期删除。


## RDB对过期key的处理
- 从内存数据库持久化数据到RDB文件
    - 持久化key之前，会检查是否过期，过期的key不进入RDB文件
- 从RDB文件恢复数据到内存数据库
    - 数据载入数据库之前，会对key先进行过期检查，如果过期，不导入数据库（主库情况）

# AOF对过期key的处理
- 从内存数据库持久化数据到AOF文件：
    - 当key过期后，还没有被删除，此时进行执行持久化操作（该key是不会进入aof文件的，因为没有发生修改命令）
    - 当key过期后，在发生删除操作时，程序会向aof文件追加一条del命令（在将来的以aof文件恢复数据的时候该过期的键就会被删掉）
- AOF重写
    - 重写时，会先判断key是否过期，已过期的key不会重写到aof文件 